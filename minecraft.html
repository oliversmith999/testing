<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Voxel World Builder</title>
    <!-- Load Tailwind CSS for styling the UI elements -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game container */
        #game-container {
            width: 90vw;
            height: 90vh;
            max-width: 1000px;
            max-height: 700px;
            cursor: pointer; /* Hint that the user should click to start */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4 text-white font-sans">
<a href="index.html">HOME</a>
    <h1 class="text-3xl font-bold mb-4 text-green-400">Voxel World Builder</h1>

    <!-- Game Container for the Canvas -->
    <div id="game-container" class="relative rounded-lg shadow-2xl border-4 border-gray-700">
        <!-- The Three.js renderer will automatically create and use a canvas here -->
    </div>

    <!-- Instructions Overlay (Blocker) -->
    <div id="blocker" class="fixed inset-0 bg-gray-900/95 flex flex-col items-center justify-center text-center z-50 transition-opacity duration-500">
        <div class="bg-gray-800 p-8 rounded-xl shadow-xl max-w-lg mx-4">
            <h2 class="text-2xl font-semibold mb-4 text-green-300">Welcome to the Voxel World!</h2>
            <p class="mb-6 text-gray-300">Click anywhere on the screen to start building.</p>

            <div class="grid grid-cols-2 gap-4 text-left p-4 border border-gray-700 rounded-lg">
                <div class="text-green-400 font-bold">Movement:</div>
                <div class="text-gray-200">W, A, S, D</div>
                
                <div class="text-green-400 font-bold">Jump:</div>
                <div class="text-gray-200">Spacebar</div>
                
                <div class="text-green-400 font-bold">Look/Aim:</div>
                <div class="text-gray-200">Mouse Movement</div>
                
                <div class="text-green-400 font-bold">Place Block:</div>
                <div class="text-gray-200">Left Click (LMB)</div>
                
                <div class="text-green-400 font-bold">Break Block:</div>
                <div class="text-gray-200">Right Click (RMB)</div>

                <div class="col-span-2 mt-2 text-sm text-yellow-400">
                    Press <span class="font-mono bg-gray-700 px-1 py-0.5 rounded">ESC</span> to release the cursor.
                </div>
            </div>
        </div>
    </div>
    
    <div id="status" class="mt-4 text-lg font-mono text-gray-400">Current Block: <span class="text-yellow-300">Stone</span></div>

    <!-- Load Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load PointerLockControls for first-person camera -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

    <script>
        // Set the log level for debugging (optional but useful for complex apps)
        // setLogLevel('Debug');
        
        let camera, scene, renderer, controls;
        let raycaster;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        const PI_2 = Math.PI / 2;

        // Block variables
        const BLOCK_SIZE = 1;
        const GRID_DIMENSION = 32; // Create a 32x32 area of initial blocks
        const blocks = []; // Array to store placed block objects
        const blockMaterials = {
            'Stone': new THREE.MeshLambertMaterial({ color: 0x808080 }),
            'Grass': new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
            'Dirt': new THREE.MeshLambertMaterial({ color: 0x795548 }),
        };
        let currentBlockType = 'Stone';

        // --- CORE INITIALIZATION ---

        function init() {
            const container = document.getElementById('game-container');

            // 1. Scene and Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xbfd1e5);
            scene.fog = new THREE.Fog(0xbfd1e5, 0, 50);

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(GRID_DIMENSION * BLOCK_SIZE / 2, BLOCK_SIZE * 2, GRID_DIMENSION * BLOCK_SIZE / 2);

            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // 3. Lighting
            const ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // 4. Controls (PointerLockControls)
            controls = new THREE.PointerLockControls(camera, renderer.domElement);

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('blocker');

            instructions.addEventListener('click', function () {
                controls.lock();
            });

            controls.addEventListener('lock', function () {
                blocker.style.opacity = '0';
                setTimeout(() => blocker.style.display = 'none', 500);
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'flex';
                blocker.style.opacity = '1';
            });

            scene.add(controls.getObject());

            // 5. Raycaster for Block Interaction
            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 10);

            // 6. Initial Ground Generation
            generateGround();

            // 7. Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onDocumentMouseDown);
        }

        // --- GAME WORLD FUNCTIONS ---

        function generateGround() {
            const blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const groundY = -BLOCK_SIZE / 2;

            for (let x = 0; x < GRID_DIMENSION; x++) {
                for (let z = 0; z < GRID_DIMENSION; z++) {
                    // Create Grass block
                    const grassMesh = new THREE.Mesh(blockGeometry, blockMaterials['Grass']);
                    grassMesh.position.set(
                        x * BLOCK_SIZE - (GRID_DIMENSION * BLOCK_SIZE / 2) + BLOCK_SIZE / 2,
                        groundY,
                        z * BLOCK_SIZE - (GRID_DIMENSION * BLOCK_SIZE / 2) + BLOCK_SIZE / 2
                    );
                    grassMesh.userData.type = 'Grass';
                    scene.add(grassMesh);
                    blocks.push(grassMesh);

                    // Create Dirt block underneath
                    const dirtMesh = new THREE.Mesh(blockGeometry, blockMaterials['Dirt']);
                    dirtMesh.position.set(grassMesh.position.x, groundY - BLOCK_SIZE, grassMesh.position.z);
                    dirtMesh.userData.type = 'Dirt';
                    scene.add(dirtMesh);
                    blocks.push(dirtMesh);
                }
            }
        }

        function placeBlock(intersect) {
            const normal = intersect.face.normal;
            const newPos = intersect.point.clone().add(normal.clone().multiplyScalar(BLOCK_SIZE / 2));

            // Snap position to grid center
            const snapX = Math.round(newPos.x / BLOCK_SIZE) * BLOCK_SIZE;
            const snapY = Math.round(newPos.y / BLOCK_SIZE) * BLOCK_SIZE;
            const snapZ = Math.round(newPos.z / BLOCK_SIZE) * BLOCK_SIZE;

            const newBlock = new THREE.Mesh(
                new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE),
                blockMaterials[currentBlockType]
            );
            newBlock.position.set(snapX, snapY, snapZ);
            newBlock.userData.type = currentBlockType;

            scene.add(newBlock);
            blocks.push(newBlock);
        }

        function removeBlock(intersect) {
            // The object to remove is the one intersected
            scene.remove(intersect.object);
            
            // Remove from the blocks array
            const index = blocks.indexOf(intersect.object);
            if (index > -1) {
                blocks.splice(index, 1);
            }
        }


        // --- EVENT HANDLERS ---

        function onWindowResize() {
            const container = document.getElementById('game-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function onKeyDown(event) {
            switch (event.keyCode) {
                case 38: // UP (W)
                case 87: // W
                    moveForward = true;
                    break;
                case 37: // LEFT (A)
                case 65: // A
                    moveLeft = true;
                    break;
                case 40: // DOWN (S)
                case 83: // S
                    moveBackward = true;
                    break;
                case 39: // RIGHT (D)
                case 68: // D
                    moveRight = true;
                    break;
                case 32: // Space
                    if (canJump === true) velocity.y += 15; // Simple jump velocity
                    canJump = false;
                    break;
                case 49: // Key 1 for Stone
                    currentBlockType = 'Stone';
                    document.getElementById('status').innerHTML = 'Current Block: <span class="text-yellow-300">Stone</span>';
                    break;
                case 50: // Key 2 for Grass
                    currentBlockType = 'Grass';
                    document.getElementById('status').innerHTML = 'Current Block: <span class="text-green-400">Grass</span>';
                    break;
                case 51: // Key 3 for Dirt
                    currentBlockType = 'Dirt';
                    document.getElementById('status').innerHTML = 'Current Block: <span class="text-amber-600">Dirt</span>';
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.keyCode) {
                case 38: // UP (W)
                case 87: // W
                    moveForward = false;
                    break;
                case 37: // LEFT (A)
                case 65: // A
                    moveLeft = false;
                    break;
                case 40: // DOWN (S)
                case 83: // S
                    moveBackward = false;
                    break;
                case 39: // RIGHT (D)
                case 68: // D
                    moveRight = false;
                    break;
            }
        }

        function onDocumentMouseDown(event) {
            if (!controls.isLocked) return;

            // Update the raycaster to shoot from the center of the camera view
            raycaster.setFromCamera({ x: 0, y: 0 }, camera); 
            
            // Find intersections with all blocks
            const intersects = raycaster.intersectObjects(blocks);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                // Left click (0) is for placing a block
                if (event.button === 0) {
                    placeBlock(intersect);
                } 
                // Right click (2) is for removing a block
                else if (event.button === 2) {
                    // Check if we are trying to remove the ground layer (optional check)
                    if (intersect.object.position.y > 0) {
                        removeBlock(intersect);
                    } else {
                        console.log("Cannot break base layer.");
                    }
                }
            } else if (event.button === 0) {
                 // Left-click in empty space does nothing currently
                 console.log("No block targeted for placement.");
            }

            // Prevent context menu from appearing on right click
            if (event.button === 2) event.preventDefault();
        }

        // --- ANIMATION LOOP ---

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();

            if (controls.isLocked === true) {
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 10.0 * delta; // Gravity

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // Ensure constant movement speed

                if (moveForward || moveBackward) velocity.z -= direction.z * 20.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 20.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += velocity.y * delta; // New Y position

                if (controls.getObject().position.y < BLOCK_SIZE * 2) {
                    velocity.y = 0;
                    controls.getObject().position.y = BLOCK_SIZE * 2;
                    canJump = true;
                }
            }

            prevTime = time;

            renderer.render(scene, camera);
        }

        // Start the game initialization when the window loads
        window.onload = function () {
            init();
            animate(); 
        };
    </script>
</body>
</html>