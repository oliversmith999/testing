<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single-Page Snake Game</title>
    
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            user-select: none; /* Prevents text selection while playing */
        }

        h1 {
            color: #2c3e50;
        }

        #gameCanvas {
            /* Define the border and background for the game area */
            border: 5px solid #2c3e50;
            background-color: #a7f5a7; /* Light green field */
        }

        #score {
            margin: 20px 0;
            font-size: 1.5em;
            font-weight: bold;
            color: #e74c3c;
        }

        .instructions {
            margin-top: 10px;
            font-size: 0.9em;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <a href="index.html">HOME</a>
    <h1>Classic Snake Game</h1>
    
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    
    <div id="score">Score: 0</div>
    <div class="instructions">Use the **Arrow Keys** to move.</div>

    <script>
        // --- GAME CONSTANTS AND INITIALIZATION ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        const TILE_SIZE = 20; // Size of each grid square in pixels
        // The grid is 20x20 since 400/20 = 20
        const GRID_SIZE = canvas.width / TILE_SIZE; 
        
        let snake;
        let food;
        let dx; // Horizontal velocity (direction)
        let dy; // Vertical velocity (direction)
        let score;
        let gameInterval;
        let changingDirection = false; // Flag to prevent multiple direction changes per tick

        function initializeGame() {
            snake = [
                { x: 10 * TILE_SIZE, y: 10 * TILE_SIZE }, // Head
                { x: 9 * TILE_SIZE, y: 10 * TILE_SIZE },
                { x: 8 * TILE_SIZE, y: 10 * TILE_SIZE },
            ];
            food = generateFood();
            dx = TILE_SIZE; // Start moving right
            dy = 0;
            score = 0;
            scoreDisplay.textContent = 'Score: 0';
            changingDirection = false;
        }

        // --- DRAWING FUNCTIONS ---

        function drawTile(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            // Optional: Draw border for grid effect
            ctx.strokeStyle = '#a7f5a7';
            ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
        }

        function drawSnake() {
            snake.forEach((segment, index) => {
                // Head is darker green
                const color = index === 0 ? '#27ae60' : '#2ecc71'; 
                drawTile(segment.x, segment.y, color);
            });
        }

        function drawFood() {
             // Red food
            drawTile(food.x, food.y, '#e74c3c'); 
        }

        // --- GAME LOGIC FUNCTIONS ---

        function generateFood() {
            let newFood;
            // Loop until a spot not occupied by the snake is found
            do {
                const foodX = Math.floor(Math.random() * GRID_SIZE) * TILE_SIZE;
                const foodY = Math.floor(Math.random() * GRID_SIZE) * TILE_SIZE;
                newFood = { x: foodX, y: foodY };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
            
            return newFood;
        }

        function moveSnake() {
            changingDirection = false;
            
            // 1. Create the new snake head
            const head = { 
                x: snake[0].x + dx, 
                y: snake[0].y + dy 
            };
            
            // Add the new head to the beginning of the snake array
            snake.unshift(head);

            // 2. Check if snake ate the food
            if (head.x === food.x && head.y === food.y) {
                // Increase score and generate new food
                score += 10;
                scoreDisplay.textContent = `Score: ${score}`;
                food = generateFood();
                // We DON'T remove the tail, so the snake grows
            } else {
                // Remove the last segment (the tail)
                snake.pop();
            }
        }

        function checkCollision() {
            const head = snake[0];
            
            // 1. Check for wall collision
            const hitWall = head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height;
            
            // 2. Check for self collision (start checking from the 4th segment)
            const hitSelf = snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);

            return hitWall || hitSelf;
        }

        function endGame() {
            clearInterval(gameInterval);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
            ctx.font = '20px Arial';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
            
            // Optional: Re-initialize the game on a key press
            document.addEventListener('keydown', startGame, { once: true });
        }

        // --- MAIN GAME LOOP ---

        function gameLoop() {
            if (checkCollision()) {
                endGame();
                return;
            }

            // Clear the canvas for the next frame
            ctx.fillStyle = '#a7f5a7';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            moveSnake();
            drawFood();
            drawSnake();
        }

        // --- INPUT HANDLING ---

        function changeDirection(event) {
            // Key codes for Arrow Keys: Left=37, Up=38, Right=39, Down=40
            const keyPressed = event.keyCode;
            
            // Prevent changing direction more than once per frame
            if (changingDirection) return;
            changingDirection = true;

            const LEFT  = 37;
            const UP    = 38;
            const RIGHT = 39;
            const DOWN  = 40;

            const goingUp    = dy === -TILE_SIZE;
            const goingDown  = dy === TILE_SIZE;
            const goingRight = dx === TILE_SIZE;
            const goingLeft  = dx === -TILE_SIZE;

            // Update direction, ensuring the snake doesn't turn 180 degrees instantly
            if (keyPressed === LEFT && !goingRight) {
                dx = -TILE_SIZE; dy = 0;
            } else if (keyPressed === UP && !goingDown) {
                dx = 0; dy = -TILE_SIZE;
            } else if (keyPressed === RIGHT && !goingLeft) {
                dx = TILE_SIZE; dy = 0;
            } else if (keyPressed === DOWN && !goingUp) {
                dx = 0; dy = TILE_SIZE;
            }
        }
        
        function startGame() {
            initializeGame();
            // Run the game loop every 100ms (controls game speed)
            gameInterval = setInterval(gameLoop, 100); 
        }

        // Start the game when the page loads
        document.addEventListener('keydown', changeDirection);
        startGame();

    </script>
</body>
</html>